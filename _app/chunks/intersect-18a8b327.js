var v=Object.defineProperty;var i=Object.getOwnPropertySymbols;var g=Object.prototype.hasOwnProperty,h=Object.prototype.propertyIsEnumerable;var d=(r,e,t)=>e in r?v(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,o=(r,e)=>{for(var t in e||(e={}))g.call(e,t)&&d(r,t,e[t]);if(i)for(var t of i(e))h.call(e,t)&&d(r,t,e[t]);return r};const s=[],a={root:null,rootMargin:"-50% 0px -50%",threshold:0};function f(r,e=a){e=o(o({},a),e);const t=l(e);return t.observe(r),{update(n){console.log("intersection observer action update triggered")},destroy(){t.unobserve(r)}}}function l(r){const e=s.findIndex(n=>n.root==r.root&&n.rootMargin==r.rootMargin&&n.thresholds==r.threshold);if(e>-1)return s[e];const t=new IntersectionObserver(n=>{for(const c of n){const u=c.isIntersecting?"enter":"leave";c.target.dispatchEvent(new CustomEvent(u))}},r);return s.push(t),t}export{f as i};
