var v=Object.defineProperty;var i=Object.getOwnPropertySymbols;var h=Object.prototype.hasOwnProperty,g=Object.prototype.propertyIsEnumerable;var a=(t,e,r)=>e in t?v(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r,o=(t,e)=>{for(var r in e||(e={}))h.call(e,r)&&a(t,r,e[r]);if(i)for(var r of i(e))g.call(e,r)&&a(t,r,e[r]);return t};const s=[],d={root:null,rootMargin:"-50% 0px -50%",threshold:0};function f(t,e=d){e=o(o({},d),e);const r=l(e);return r.observe(t),{update(n){console.log("intersection observer action update triggered")},destroy(){r.unobserve(t)}}}function l(t){const e=s.findIndex(n=>n.root==t.root&&n.rootMargin==t.rootMargin&&n.thresholds==t.threshold);if(e>-1)return s[e];const r=new IntersectionObserver(n=>{n.forEach(c=>{const u=c.isIntersecting?"enter":"leave";c.target.dispatchEvent(new CustomEvent(u))})},t);return s.push(r),r}export{f as i};
