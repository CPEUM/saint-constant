var v=Object.defineProperty;var d=Object.getOwnPropertySymbols;var h=Object.prototype.hasOwnProperty,f=Object.prototype.propertyIsEnumerable;var u=(r,e,t)=>e in r?v(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,o=(r,e)=>{for(var t in e||(e={}))h.call(e,t)&&u(r,t,e[t]);if(d)for(var t of d(e))f.call(e,t)&&u(r,t,e[t]);return r};const s=[],a={root:null,rootMargin:"-50% 0px -50%",threshold:0};function g(r,e=a){e=o(o({},a),e);const t=b(e);return t.observe(r),{update(n){},destroy(){t.unobserve(r)}}}function b(r){const e=s.findIndex(n=>n.root==r.root&&n.rootMargin==r.rootMargin&&n.thresholds==r.threshold);if(e>-1)return s[e];const t=new IntersectionObserver(n=>{for(const c of n){const i=c.isIntersecting?"enter":"leave";c.target.dispatchEvent(new CustomEvent(i))}},r);return s.push(t),t}export{g as i};
